### Запуск: docker-compose up

```
127.0.0.1:2380                    Результаты запроса на выборку
127.0.0.1:8081                    phpMyAdmin | user:root password:secret
127.0.0.1:15672                   RabbitMq manager | user:admin password:admin
```

### Текст задачи

Тестовое задание для соискателя на вакансию backend-разработчик.
Тестовое задание необходимо выполнять в Docker инфраструктуре.
В контейнере необходимо развернуть MySQL (MariaDB)
Так же необходимо развернуть rabbitMQ, который будет состоять из одного консьюмера и одного продьюссера
Консьюмер и продьюссер должны быть написаны на “голом” PHP либо Golang.
Необходимо применить супервизор для отслеживания работоспособности консьюмера и запустить консьюмер в 5 потоков.

Продьюсер должен отправлять в сообщении URL-адрес. Кол-во сообщений и конкретные URL адреса могут быть произвольные.
Консьюмер должен поглощать сообщения с задержкой в 30 секунд и выполнять запрос по указанному адресу. Консьюмер должен
записывать в таблицу БД код ответа, response header, и контент ответа. (структура таблицы произвольная).
Если код ответа не 200, необходимо повторно один раз отослать сообщение через rabbitMQ с задержкой в 15 секунд.
Создать запрос на выборку, в котором будет выводиться общее кол-во запросов и кол-во запросов в response header которых
встречается поле 'new' со значением 1 (название поля может быть любым).

### Проблемы которые я вижу в задаче

```Консьюмер должен поглощать сообщения с задержкой в 30 секунд и выполнять запрос по указанному адресу.```

По тексту задачи понятно что нужно делать задержку в 30 секунд после каждого запроса, что по моему мнению крайне странно
ведь мы сможем обработать на сервере только 5 ссылок в 30 (+ время запроса ответа на сервере). В данной реализации я
сделал именно так как было описано в задаче. Но для обработки большего количества ссылок ограничение в 30 секунд очень
сильно скажется на скорости обработки.

### Структура проекта

```
app
 /calsses                        
    -Console.php                 Класс для обработки конольных команд продюсер/консьюмер
    -RequestModel.php	         Класс для работы с таблицой request 
    -Settings.php		 Класс для обработки настроек из папки config
 /config
    -config_docker.php           настройки для окружения докера
    -config_local.php            настройки для локального окружения
 /core
    -Configuration.php           Наследуемый куласс для обработки настроек из папки config
    -Model.php                   Наследуемый куласс для работы с DB
    -Rabbit.php                  Наследуемый куласс для работы с RabbitMQ   
    -autoload.php                файл с настройками автозагрузки классов
 /helpers
    -CurlHelper.php              Помощник для обработки url запросов
 /view
    -main.php                    Вид для страницы результатов
conf                             Настройки импортироюмые в докер окружение
docker-files                     Файлы для создания изображения PHP и supervisor
mysql    			 Файлы DB	
-console                         Вход для консоли
-index.php                       Вход для web
```

### Работа приложения
При запуске docker-compose формируется окружение и запукает supervisor ([Конфиг](https://github.com/Razputins/project/blob/master/docker-files/php/supervisor/start.conf)) которыйе в свойю очередь запускает процессы:


```project/app/classes/Console.php:37```
[producer](https://github.com/Razputins/project/blob/master/app/classes/Console.php) (1шт). producer каждую секунду отправляет сообщение с url в основную очередь RabbitMQ.
Из набора 4 ссылок. В дальнейшем можно поменять на обработчик Get запросов без проблем.
>**Внимание** при запуске приложения будет постоянно спамить сайт php.net. После теста стопнуть контейнер.




```project/app/classes/Console.php:52```
[consumer](https://github.com/Razputins/project/blob/master/app/classes/Console.php) (5шт)
consumer кажые 30сек достает сообщение из очереди и делает запрос по указанному url, если код ответа не 200 сообщение отправляется в дополнительную очередь где будет находитя 15 сек после чего вернется в основную очередь где обработается еще раз consumer-ом без задержки в 30сек.



### Запрос в базу данных для поиска new
```project/app/classes/RequestModel.php```
> SELECT COUNT(*) as over, SUM(CASE WHEN JSON_EXTRACT(header, '$.new') = 1 THEN 1 ELSE 0 END) AS new FROM {$this->table}

Такак проще всего хранить данные о заголовках запроса в json их также удобно вычитывать от туда. Но в базе PgSql это бы работало быстрее изза бинарного поиска в ```jsonb```